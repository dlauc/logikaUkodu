\chapter{Uvod: Što je logika i zašto kod?}
% Modificirani uvod.tex - čisti LaTeX format


\epigraph{Ne priliči izvrsnim ljudima da kao robovi gube sate na računanje, u poslu koji se može s punim povjerenjem prepustiti bilo kome drugome uporabom strojeva.}{Gottfried Wilhelm Leibniz\footnotemark}
\footnotetext{\emph{Machina Arithmetica in qua non Aditio tantum Subtractio 1685}, slobodni prijevod s engleskog prijevoda}


\section{Logika kao znanost o valjanom zaključivanju}


Logika proučava oblike valjanog zaključivanja i relacije logičkog slijeda. Kada kažemo da je zaključak valjan, mislimo da konkluzija nužno slijedi iz premisa. Ova nužnost proizlazi iz same strukture našeg mišljenja, neovisno o sadržaju.


Razmotrimo klasičan primjer:
\begin{enumerate}
\item Svi ljudi su smrtni.
\item Sokrat je čovjek.
\item Dakle, Sokrat je smrtan.
\end{enumerate}


Valjanost ovog zaključka ne ovisi o tome tko je Sokrat ili što znači čovjek'' i smrtan''. Ona proizlazi iz logičke forme koja ostaje valjana čak i kad zamijenimo termine:
\begin{enumerate}
\item Svi $P$ su $Q$.
\item $a$ je $P$.
\item Dakle, $a$ je $Q$.
\end{enumerate}


Moderna simbolička logika omogućava nam precizno zapisivanje ovakvih formi. U logici sudova bavimo se veznicima:
\begin{itemize}
\item Konjunkcija ($\wedge$): i'' \item Disjunkcija ($\vee$): ili''

\item Implikacija ($\rightarrow$): ako...onda'' \item Negacija ($\neg$): nije''
\end{itemize}


Logika predikata ide dalje omogućavajući kvantifikaciju:
\begin{itemize}
\item Univerzalni kvantifikator ($\forall$): ,,svi'', ,,svaki''
\item Egzistencijalni kvantifikator ($\exists$): ,,neki'', ,,postoji''
\end{itemize}


\section{Formalni jezik misli}


Gottlob Frege, utemeljitelj moderne logike, nastojao je stvoriti ..pojmovno pismo'' (\textit{Begriffsschrift}) -- formalni jezik za izražavanje čistog mišljenja, oslobođenog dvosmislenosti prirodnog jezika. Njegova vizija danas živi u programskim jezicima.


Kada pišemo Python kod:
\begin{verbatim}
def je_smrtan(x):
    return je_čovjek(x)

assert je_smrtan("Sokrat") == True
\end{verbatim}


formaliziramo logičku strukturu. Funkcija \texttt{je\_smrtan} enkodira univerzalnu tvrdnju, a \texttt{assert} provjerava konkretnu instancu.


\section{Struktura stvarnosti: Wittgensteinova slika}


Ludwig Wittgenstein u \textit{Tractatus Logico-Philosophicus} nudi radikalnu tezu: granice našeg jezika su granice našeg svijeta. Za njega, svijet je totalitet činjenica, ne stvari. Činjenice postoje u ..logičkom prostoru'' -- prostoru svih mogućih kombinacija.


Ova ideja ima izravnu programsku interpretaciju. Kada definiramo Booleove varijable:
\begin{verbatim}
kiša = True
sunce = False
vjetar = True
\end{verbatim}


definiramo točku u logičkom prostoru. S tri varijable, imamo $2^3 = 8$ mogućih svjetova. Svaki program implicitno definira takav prostor mogućnosti i pravila kretanja kroz njega.


\section{Istina i značenje: Tarskijeva semantika}


Alfred Tarski riješio je drevni problem istine kroz svoju semantičku teoriju. Njegova čuvena T-shema:


..Snijeg je bijel'' je istinito ako i samo ako snijeg je bijel.


Može se činiti trivijalnom, ali razlikuje jezik od metajezika. U Pythonu:
\begin{verbatim}
def je_istinito(izjava, model):
    return eval(izjava, model)

model = {"snijeg_je_bijel": True}
assert je_istinito("snijeg_je_bijel", model) == True
\end{verbatim}


funkcija \texttt{je\_istinito} je metajezična -- ona govori \emph{o} izjavama, ne \emph{u} njima.


\section{Dokazi kao programi: Curry-Howard izomorfizam}


Jedan od najdubljih uvida 20. stoljeća je otkriće strukturne ekvivalencije između logičkih dokaza i programa. Curry-Howard izomorfizam pokazuje:


\begin{center}
\begin{tabular}{l|l}
\textbf{Logika} & \textbf{Programiranje} \\
\hline
Formula $A \rightarrow B$ & Tip funkcije \texttt{A -> B} \\
Dokaz formule & Program tog tipa \\
Modus ponens & Aplikacija funkcije \\
Konjunkcija $A \wedge B$ & Tuple \texttt{(A, B)} \\
Disjunkcija $A \vee B$ & Union type \texttt{A | B} \\
\end{tabular}
\end{center}


Svaki put kad pišete funkciju, vi zapravo konstruirate dokaz. Svaki put kad je pozivate, primjenjujete logičko pravilo. Tipovi su teoremi, programi su dokazi!


\section{Granice formalizma: Gödelova nepotpunost}


Kurt Gödel je 1931. dokazao da svaki dovoljno bogat formalni sustav ili je nekonzistentan ili nepotpun. Postoje istinite tvrdnje koje se ne mogu dokazati unutar sustava.


Njegov dokaz koristi samoreferenciranje -- konstruira rečenicu koja kaže ..Ja nisam dokaziva''. Ako je dokaziva, sustav je nekonzistentan. Ako nije, sustav je nepotpun.


U Pythonu možemo ilustrirati Gödelov trik:
\begin{verbatim}
def gödel_rečenica(n):
    """Rečenica koja tvrdi da nije dokaziva"""
    return f"Rečenica broj {n} nije dokaziva"


\textbf{Paradoks: ako je dokaziva, onda je lažna}

\textbf{Ako nije dokaziva, onda je istinita, ali nedokaziva}

\end{verbatim}


\section{Turingovi strojevi}


Alan Turing definirao je precizni model računanja -- Turingov stroj. Pokazao je da postoje problemi koje nijedan stroj ne može riješiti, poput problema zaustavljanja.


Python interpreter je zapravo Turingov stroj (tehnički Turing potpun jezik).
Svaki program koji napišete je opis konačnog automata koji manipulira simbolima na ..traci'' (memoriji):

\begin{verbatim}
def turingov_stroj(traka, program, stanje=0):
    while stanje != "STOP":
        simbol = traka.pročitaj()
        novo_stanje, novi_simbol, smjer = program[stanje][simbol]
        traka.zapiši(novi_simbol)
        traka.pomakni(smjer)
        stanje = novo_stanje
    return traka
\end{verbatim}


\section{Od dedukcije k indukciji}

Klasična logika bavi se nužnim zaključcima. Ali većina našeg zaključivanja je probabilistička. David Hume primijetio je ,,problem indukcije'' -- iz činjenice da je sunce izašlo svaki dan do sada, ne slijedi nužno da će izaći sutra.

Bayesov teorem daje nam formalni okvir za induktivno zaključivanje:

$$P(H|E) = \frac{P(E|H) \cdot P(H)}{P(E)}$$


Gdje je $P(H|E)$ posteriorna vjerojatnost hipoteze nakon evidencije.


U Pythonu:
\begin{verbatim}
def bayes(prior, likelihood, evidence):
return (likelihood * prior) / evidence


\textbf{Medicinska dijagnoza}

p_bolest = 0.01  # 1% populacije ima bolest
p_pozitivan_test_ako_bolest = 0.99  # 99% osjetljivost
p_pozitivan_test = 0.05  # 5% ukupno pozitivnih


p_bolest_ako_pozitivan = bayes(
p_bolest,
p_pozitivan_test_ako_bolest,
p_pozitivan_test
)


\textbf{Rezultat: 0.198 ili 19.8%}

\end{verbatim}


\section{Paradoksi i granice}


Logika je puna paradoksa koji testiraju naše razumijevanje:


\textbf{Russellov paradoks}: Skup svih skupova koji ne sadrže sebe. Sadrži li sebe?


\textbf{Paradoks lažljivca}: ..Ova rečenica je neistinita.'' Istinita ili neistinita?


\textbf{Sorites paradoks}: Jedna zrna pijeska nije hrpa. Dodavanje jednog zrna ne čini hrpu. Dakle, nikad nema hrpe?


Ovi paradoksi nisu samo zagonetke -- oni otkrivaju fundamentalne limite formalnih sustava i potiču razvoj novih logika (parakontistentne, fuzzy, relevantne).


\section{Primjena u stvarnom svijetu}


Logika kroz kod nije samo akademska vježba. Primjene su svugdje:


\textbf{Baze podataka} koriste logiku predikata (SQL je zapravo logički jezik):
\begin{verbatim}
SELECT * FROM studenti
WHERE godina > 2 AND prosjek >= 4.0
\end{verbatim}


\textbf{Verifikacija softvera} dokazuje korektnost kritičnih sustava:
\begin{verbatim}
@requires(x >= 0)
@ensures(rezultat >= 0)
def korijen(x):
    return sqrt(x)
\end{verbatim}


\textbf{Umjetna inteligencija} koristi logičko zaključivanje za planiranje i donošenje odluka.




\section{Putovanje koje slijedi}


Ovaj udžbenik vodi vas kroz postupno otkrivanje veze između logike i programiranja. Svaki koncept gradit ćemo od temelja:


\begin{enumerate}
\item \textbf{Intuicija}: Zašto je koncept važan?
\item \textbf{Formalizacija}: Precizna matematička definicija
\item \textbf{Implementacija}: Radni Python kod
\item \textbf{Eksploracija}: Eksperimenti i varijacije
\end{enumerate}


Ne učite samo \emph{o} logici -- prakticirajte logiku kroz kod. Svaka Jupyter bilježnica je laboratorij. Mijenjajte parametre, testirajte granične slučajeve, pokušajte pokvariti kod. Kroz ove eksperimente razvit ćete dublju intuiciju od pukog čitanja.


Zapamtite: u logici, kao i u programiranju, jedini način učenja je činjenjem. Greške su dragocjene -- one otkrivaju skrivene pretpostavke i suptilne istine.


Započnimo ovo putovanje kroz svjetove logike, gdje svaki novi koncept otvara vrata dubljeg razumijevanja načina na koji mislimo, zaključujemo i stvaramo.

